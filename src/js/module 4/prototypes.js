// // prototypes - резервное хранилище - получить доступ к ссылке на другой объект

// const objA = {
//   x: 1, // собственное свойство
// };

// // console.log(objA.hasOwnProperty('x')); // true
// // console.log(objA.hasOwnProperty('z')); // false
// // console.log(objA.y); // undefined

// console.log('objA', objA);

// const objB = Object.create(objA);
// objB.x = 999;
// objB.y = 2;
// console.log('objB', objB);

// console.log(objA.hasOwnProperty('y')); // false

// /*

// 1. Поиск начинается с собсветнных свойств
// 2. Если нет - переходит к цепочке прототипов
// 3. Поиск прекращается до первого совпадения (если не находит по цепочке, вернет undefined)
// 4. Возвращается значения свойств

// */

// ===============================================

// // ООП - класс, экземпляр (объект), интерфейс

// /*
// Класс - чертёж машины
// Экземпляр - одна машина (после производства) - 4 колеса, двери, руль и т.д. - набор хараткеристик одинаковый, но разные цвета кузова, салона и тд.
// Интерфейс - набор доступных свойств и методов (действий) - завести машину, развить скорость и т.д.
// */

// // Класс/функция-конструктор (чертеж машины)
// // существительное с большой буквы
// const Car = function ({ brand, model, price } = {}) {
//   // 2. Функция вызывается в контексте созданного объекта (в this записывается ссылка на него)
//   //   console.log(this); // Car {}
//   //   console.log(config);

//   this.brand = brand;
//   this.model = model;
//   this.price = price;

//   // 3. (АВТОМАТИЧЕСКИ) в свойство this.__proto__ записывается ссылка на объект Car.prototype (это ПРОТОТИП будущего объекта (экземпляра))
//   //   метод, который будет изменять цену (делается копия каждого экземпляра)
//   this.changePrice = function (newPrice) {
//     this.price = newPrice;
//   };

//   // 4. Ссылка на объект возвращается в место вызова new Car
//   // чтобы достучаться до оригинального экземпляра, используется constructor
// };

// console.log(Car.prototype); // {constructor: ƒ}

// Car.prototype.sayHi = function () {
//   console.log('Car.prototype.sayHi -> this', this);
// };

// Car.prototype.changePrice = function (newPrice) {
//   this.price = newPrice;
// };

// console.log(Car.prototype);

// // Экземпляр (new - это оператор)
// // 1. вызов функции через new под капотом создаёт пустой объект
// const myCar = new Car({ brand: 'Audi', model: 'Q3', price: 35000 });
// console.log(myCar); // Car {a: 5}

// myCar.sayHi();

// const myCar2 = new Car({ brand: 'BMW', model: 'X5', price: 50000 });
// console.log(myCar2);

// const myCar3 = new Car();
// console.log(myCar3);

// ===============================================

// ИТОГ
// 1. У каждого объхекта есть свойство прото
// 2. в этом свойстве лежит ссылка на его прототип, то есть другой объект
// 3. При создании литерала объекта в свойство прото записывается ссылка на fn.prototype

// const objA = {
//   x: 5,
// };

// console.log(objA.__proto__ === Object.prototype); // true (два объекта равны, когда это ссылка на один и тот же объект)

// 4. Функция-конструктор это просто функция
// 5. Вся магия происходит благодаря оператора new (у функции под капотом два слота: call и construct)
// 6. Если функция вызывается через new, создаётся пустой объект, в контексте которого вызывается эта функция
// 7. (АВТОМАТИЧЕСКИ) в свойство this.__proto__ записывается ссылка на объект Функция-конструктор.prototype (это ПРОТОТИП будущего объекта (экземпляра))

// this = Object.create(User.prototype)

// 8. Ссылка на этот объект возвращается в место вызова new Функция()

// ===============================================

// СТАТИЧЕСКИЕ СВОЙСТВА
// методы на прототипе (на экземплярах)
// статические методы и свойства (доступны только на самом конструкторе, не нужен this)

// Object.keys()
// Object.values()

// ===============================================

// ПЛАГИНЫ - готовая библиотека для решения каких-то задач



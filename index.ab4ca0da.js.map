{"mappings":"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","sources":["node_modules/@swc/helpers/lib/_array_without_holes.js","node_modules/@swc/helpers/lib/_array_like_to_array.js","node_modules/@swc/helpers/lib/_iterable_to_array.js","node_modules/@swc/helpers/lib/_non_iterable_spread.js","node_modules/@swc/helpers/lib/_unsupported_iterable_to_array.js","node_modules/@swc/helpers/lib/_to_consumable_array.js","src/js/ownPractice/ownPractice.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _arrayWithoutHoles;\nvar _arrayLikeToArray = _interopRequireDefault(require(\"./_array_like_to_array\"));\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return (0, _arrayLikeToArray).default(arr);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _arrayLikeToArray;\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _iterableToArray;\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _nonIterableSpread;\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _unsupportedIterableToArray;\nvar _arrayLikeToArray = _interopRequireDefault(require(\"./_array_like_to_array\"));\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return (0, _arrayLikeToArray).default(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0, _arrayLikeToArray).default(o, minLen);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _toConsumableArray;\nvar _arrayWithoutHoles = _interopRequireDefault(require(\"./_array_without_holes\"));\nvar _iterableToArray = _interopRequireDefault(require(\"./_iterable_to_array\"));\nvar _nonIterableSpread = _interopRequireDefault(require(\"./_non_iterable_spread\"));\nvar _unsupportedIterableToArray = _interopRequireDefault(require(\"./_unsupported_iterable_to_array\"));\nfunction _toConsumableArray(arr) {\n    return (0, _arrayWithoutHoles).default(arr) || (0, _iterableToArray).default(arr) || (0, _unsupportedIterableToArray).default(arr) || (0, _nonIterableSpread).default();\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","// const a = 2.55181;\n// console.log(a.toFixed(1)); // 2.2\n// console.log(Math.ceil(a)); // 3\n// console.log(Math.floor(a)); // 2\n// console.log(Math.round(a)); // 3\n\n// console.log(Math.max(21, 141, 51, 51, 51, 515, 15452)); // 15451\n// console.log(Math.min(21, 141, 51, 51, 51, 515, 15452)); // 21\n\n// // console.log(Math.pow(2, 4)); // 16\n// const math = Math.random() * (100 - 1) + 1;\n// const fixed = math.toFixed(0);\n// console.log(fixed);\n\n// const managerName = 'Andrey';\n\n// if (managerName === 'Serhii') {\n//   console.log('Yes');\n// } else if (managerName === 'Anton') {\n//   console.log('Manager Anton');\n// } else {\n//   console.log('Somebody else');\n// }\n\n// switch (managerName) {\n//   case 'Serhii':\n//     console.log('Yes');\n//     break;\n//   case 'Anton':\n//     console.log('Manager Anton');\n//     break;\n//   default:\n//     console.log('Somebody else');\n// }\n\n// ===========\n\n// const object = {\n//   name: 'Serhii',\n//   age: 30,\n//   height: 179,\n\n//   someData() {\n//     if (this.haveChildren) {\n//       console.log('yes, he have a children');\n//       return;\n//     } else {\n//       console.log('no, he haven`t any children');\n//       return;\n//     }\n//   },\n\n//   anotherData(companyName) {\n//     if (companyName) {\n//       console.log('ecosphere');\n//     } else {\n//       console.log('unemployed');\n//     }\n\n//     if (this.age > 30) {\n//       console.log('Yes, he is employee');\n//     } else if (this.age < 30) {\n//       console.log('early to work on this company');\n//     } else {\n//       console.log(`he is ${this.age}`);\n//     }\n//   },\n// };\n\n// object.haveChildren = true;\n\n// object.someData();\n// object.anotherData('ecosphere');\n\n// ===============================================\n\n// array methods\n\n// три основы, которые НЕОБХОДИМО знать:\n// A. что делает?\n// B. что принимает?\n// C. что возвращает?\n\n/* \n1. forEach() + callbacks - ничего не возвращает, только перебирает\n2. map()\n3. flatMap()\n4. filter()\n5. find() - ищет условие, которое соответствует true\n6. findIndex()\n7. every()\n8. some()\n9. sort()\n*/\n\n// ===========\n\n// 1\n// поэлементно перебирает массив, замена фор, ничего не возвраает, невозможно прервать итерацию\n\n// console.log('forEach:');\n\n// const numbers = [5, 10, 15, 20, 25];\n\n// console.log(numbers); // array\n\n// numbers.forEach((number) => {\n//   console.log(number); // elements of array\n// });\n\n// ===============================================\n\n// console.log('map:');\n\n// const numbers = [5, 10, 15, 20, 25];\n\n// // поэлементно перебирает каждый элемент, не изменяет оригинальный массив, возвращает новый массив такой же длинны\n// // неявный возврат возвращает undefined\n// const result = numbers.map((number) => {\n//   return number * 2;\n// });\n\n// console.log(result);\n\n// ===========\n\n// // получение массива имен игроков\n// const players = [\n//   { id: 'player-1', name: 'Mango', timePlayed: 310, points: 54, online: false },\n//   { id: 'player-2', name: 'Poly', timePlayed: 470, points: 92, online: true },\n//   { id: 'player-3', name: 'Kiwi', timePlayed: 230, points: 48, online: true },\n//   { id: 'player-4', name: 'Ajax', timePlayed: 150, points: 71, online: false },\n//   { id: 'player-5', name: 'Chelsy', timePlayed: 80, points: 48, online: true },\n// ];\n\n// const playersNames = players.map((player) => player.name);\n// console.log(playersNames); // array of players names\n\n// const playersIds = players.map((player) => player.id);\n// console.log(playersIds); // array of players ids\n\n// ===========\n\n// // для каждого игрока обновить свойства\n// const updatedPlayers = players.map((player) => {\n//   return {\n//     ...player,\n//     points: player.points * 1.1,\n//   };\n// });\n\n// console.log(updatedPlayers);\n\n// ===========\n\n// // достучаться до отдельного свойства отдельного объекта\n// const playerIdToUpdate = 'player-4';\n\n// const timePlayed = players.map((player) =>\n//   playerIdToUpdate === player.id\n//     ? { ...player, timePlayed: player.timePlayed + 100 }\n//     : player\n// );\n\n// const timePlayed = players.map((player) => {\n//   if (playerIdToUpdate === player.id) {\n//     return { ...player, timePlayed: player.timePlayed + 100 };\n//   }\n//   return player;\n// });\n\n// console.table(timePlayed);\n\n// ===============================================\n\n// console.log('filter:');\n\n/* \n- перебирает каждый элемент массива\n- фильтрует элементы по условию\n- возвращает новый массив (с элементами или пустой)\n- добавляет в массив элементы, которые удовлетворяет условию коллбек функции\ntrue - добавляется в новый массив\nfalse - не добавляется в новый массив\n*/\n\n// const numbers = [5, 10, 15, 20, 25];\n\n// const filtered = numbers.filter((number) => {\n//   console.log(number); // elements of array\n//   return number < 15 || number > 20;\n// });\n\n// console.log(filtered); // all elements who less than condition [5, 10,]\n\n// ===========\n\n// const players = [\n//   { id: 'player-1', name: 'Mango', timePlayed: 310, points: 54, online: false },\n//   { id: 'player-2', name: 'Poly', timePlayed: 470, points: 92, online: true },\n//   { id: 'player-3', name: 'Kiwi', timePlayed: 230, points: 48, online: true },\n//   { id: 'player-4', name: 'Ajax', timePlayed: 150, points: 71, online: false },\n//   { id: 'player-5', name: 'Chelsy', timePlayed: 80, points: 48, online: true },\n// ];\n\n// const filteredOnline = players.filter((player) => player.online);\n// console.table(filteredOnline);\n\n// const filteredOffline = players.filter((player) => !player.online);\n// console.table(filteredOffline);\n\n// ===============================================\n// little shallow\n\n// const myVar = 'string';\n\n// function someFunc() {\n//   const myVar = 'another string';\n//   console.log(myVar);\n//   return myVar;\n// }\n\n// console.log(myVar === someFunc()); // false\n\n// ===============================================\n\n// const counter = {\n//   value: 0,\n//   increment(value) {\n//     console.log('increment -> this', this);\n//     this.value += value;\n//   },\n//   decrement(value) {\n//     console.log('decrement -> this', this);\n//     this.value -= value;\n//   },\n// };\n\n// const updateCounter = function (value, operation) {\n//   operation(value);\n// };\n\n// updateCounter(10, counter.increment); // undefined (нету контекста)\n// updateCounter(5, counter.decrement); // undefined (нету контекста)\n\n// // ПРИ ПЕРЕДАЧЕ МЕТОДА ОБЪЕКТА, КАК КОЛЛБЕКА - КОНТЕКСТ НЕ СОХРАНЯЕТСЯ\n\n// ===============================================\n\n// const func = function () {\n//   return 5;\n// };\n\n// console.log(func); // передана ссылка на функцию, а не вызов\n\n// ===============================================\n\n// // call/apply - принудительный вызов функции в контексте (ТОЛЬКО НА ОДИН ВЫЗОВ)\n// // функция - это объект\n\n// // fn.call(ссылка на объект (контекст), остальные необязательные аргументы)\n\n// const func = function () {\n//   console.log('this', this);\n// };\n\n// const objA = {\n//   a: 5,\n//   b: 10,\n// };\n\n// func.call(objA, 1, 2, 3, 4, 5); // контекст, передача необязательных аргументов\n// func.apply(objA, [1, 2, 3, 4, 5]); // контекст, передача необязательных аргументов в массиве\n\n// // не хранить одинаковые методы на объектах, а вынести одну независимую и потом вызвать в каком-то контекте\n\n// ===============================================\n\n// // bind() - привязка контекста НАВСЕГДА\n// // делает копию метода и привязывает контекст НАВСЕГДА\n// // оригинальная функция не изменяется\n\n// const counter = {\n//   value: 0,\n//   increment(value) {\n//     console.log('increment -> this', this);\n//     this.value += value;\n//   },\n//   decrement(value) {\n//     console.log('decrement -> this', this);\n//     this.value -= value;\n//   },\n// };\n\n// const updateCounter = function (value, operation) {\n//   operation(value);\n// };\n\n// updateCounter(10, counter.increment.bind(counter));\n// updateCounter(5, counter.decrement.bind(counter));\n\n// ===============================================\n\n// const objectC = {\n//   first: 1,\n// };\n// console.log(objectC);\n\n// const objectB = Object.create(objectC);\n// objectB.second = 2;\n// console.log(objectB);\n\n// const objectA = Object.create(objectB);\n// objectA.third = 3;\n// console.log(objectA);\n\n// ===============================================\n\n// const User = function ({ email, password } = {}) {\n//   this.email = email;\n//   this.password = password;\n// };\n\n// // console.log(User.prototype); // автоматически создаётся объект\n\n// User.prototype.changeEmail = function (newMail) {\n//   this.email = newMail;\n// };\n\n// const mango = new User({ email: 'mango@mail.com', password: 11111 });\n\n// mango.changeEmail('my-new-mail@mail.com');\n\n// User.logInfo = function (obj) {\n//   console.log(obj);\n// };\n\n// User.logInfo(mango);\n\n// ===============================================\n\n// const object = {\n//   name: 'Serhii',\n//   age: 35,\n// };\n\n// console.log(object);\n\n// object.profession = 'Developer';\n\n// console.log(object.hasOwnProperty('profession'));\n\n// const newInfo = Object.create(object); // прототип объекта object\n// newInfo.profession = 'Manager'\n\n// console.log(newInfo.hasOwnProperty('profession'));\n\n// ===============================================\n\n// const numbers = [1, 2, 3, 4, 5];\n\n// const result = numbers.every((number) => number < 0);\n// console.log(result);\n\n// const result2 = numbers.some((number) => number > 5);\n// console.log(result2);\n\n// const arrayOfObjects = [\n//   { name: 'first', first: 1 },\n//   { name: 'second', second: 2 },\n//   { name: 'third', third: 3 },\n// ];\n\n// const footballers = ['Harry Kane', 'Hugo Lloris', 'Christian Eriksen'];\n\n// const changeToUpper = footballers.map((footballer) => footballer.toUpperCase());\n// console.log(changeToUpper);\n\n// const changeToLower = footballers.map((footballer) => footballer.toLowerCase());\n// console.log(changeToLower);\n\n// const footballers = [\n//   { name: 'Harry Kane', clubs: 'Bayern Munich' },\n//   { name: 'Hugo Lloris', clubs: 'Tottenham Hotspur' },\n//   {\n//     name: 'Christian Eriksen',\n//     clubs: 'Manchester United',\n//   },\n// ];\n\n// const findClub = footballers.find(\n//   (footballer) => footballer.clubs === 'Tottenham Hotspur'\n// );\n// console.log(findClub);\n\n// const findClubByIndex = footballers.findIndex(\n//   (footballer) => footballer.clubs === 'Tottenham Hotspur'\n// );\n// console.log(findClubByIndex);\n\n// const footballers = [\n//   { name: 'Harry Kane', clubs: ['Tottenham Hotspur', 'Bayern Munich'] },\n//   { name: 'Hugo Lloris', clubs: ['Nice', 'Tottenham Hotspur'] },\n//   {\n//     name: 'Christian Eriksen',\n//     clubs: ['Tottenham Hotspur', 'Manchester United'],\n//   },\n// ];\n\n// const clubs = footballers.flatMap((footballer) => footballer.clubs);\n// console.log(clubs);\n\n// const oneClub = clubs.filter((club, idx, arr) => arr.indexOf(club) === idx);\n// console.log(oneClub);\n\n// ===============================================\n\n// //  ЗАДАЧА С КАРТАМИ\n// let count = 0;\n\n// function cc(card) {\n//   switch (card) {\n//     case 2:\n//     case 3:\n//     case 4:\n//     case 5:\n//     case 6:\n//       count += 1;\n//       break;\n\n//     case 10:\n//     case \"J\":\n//     case \"Q\":\n//     case \"K\":\n//     case \"A\":\n//       count -= 1;\n//       break;\n//   }\n\n//   if (count > 0) {\n//     return console.log(count + \" Bet\");\n//   } else {\n//     return console.log(count + \" Hold\");\n//   }\n// }\n\n// cc(2); cc(3); cc(7); cc('K'); cc('A');\n\n// ===============================================\n\n// РЕКУРСИЯ\n// Два основных правила:\n// // 1. базовое условие\n// // 2. движение по рекурсии (сценарий)\n\n// let count = 0\n\n// function recurse() {\n//   if(count === 5) {\n//     return 'Done'\n//   }\n\n//   count++;\n//   return recurse();\n// }\n\n// console.log(recurse())\n// console.log(count);\n\n// ===========\n\n// function pow(x, y) {\n//   if (y === 0) {\n//     return 1;\n//   }\n//   return x * pow(x, y - 1)\n// }\n\n// const result = pow(5, 3)\n// console.log(result);\n\n// ===========\n\n// const contacts = [\n//   {\n//     firstName: \"Akira\",\n//     lastName: \"Laine\",\n//     number: \"0543236543\",\n//     likes: [\"Pizza\", \"Coding\", \"Brownie Points\"],\n//   },\n//   {\n//     firstName: \"Harry\",\n//     lastName: \"Potter\",\n//     number: \"0994372684\",\n//     likes: [\"Hogwarts\", \"Magic\", \"Hagrid\"],\n//   },\n//   {\n//     firstName: \"Sherlock\",\n//     lastName: \"Holmes\",\n//     number: \"0487345643\",\n//     likes: [\"Intriguing Cases\", \"Violin\"],\n//   },\n//   {\n//     firstName: \"Kristian\",\n//     lastName: \"Vos\",\n//     number: \"unknown\",\n//     likes: [\"JavaScript\", \"Gaming\", \"Foxes\"],\n//   },\n// ];\n\n// function lookUpProfile(name, prop) {\n// for (let x = 0; x < contacts.length; x++) {\n//   if (contacts[x].firstName === name) {\n//     if (contacts[x].hasOwnProperty(prop)) {\n//       return contacts[x][prop]\n//     } else {\n//       return 'No such property'\n//     }\n//   }\n// }\n// return 'No such contact'\n// }\n\n// lookUpProfile(\"Akira\", \"likes\");\n\n// ===========\n\n// function randomWholeNum() {\n//   return (Math.floor(Math.random() * 9));\n// }\n\n// console.log(randomWholeNum());\n\n// ===========\n\n// function convertToInteger(str) {\n//   return parseInt(str)\n//   }\n\n// console.log(convertToInteger(\"56\"));\n\n// ===========\n\n// function checkSign(num) {\n//   return num > 0 ? 'positive'\n//   : num < 0 ? 'negative'\n//   : 'zero'\n// }\n\n// (checkSign(10));\n\n// ===============================================\n\n// const words = ['spray', 'elite', 'exuberant', 'destruction', 'present'];\n// const result = words.filter((word) => word.length > 6);\n// console.log(result); // [\"exuberant\", \"destruction\", \"present\"]\n\n// ===========\n\n// const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n// const result2 = arr.filter((element) => element < 5)\n// console.log(result2);\n\n// ===========\n\n// // Изменение всех элементов\n// let words = [\"spray\", \"limit\", \"exuberant\", \"destruction\", \"elite\", \"present\"];\n\n// const modifiedWords = words.filter((word, index, arr) => {\n//   arr[index + 1] += \" extra\";\n//   return word.length < 6;\n// });\n\n// console.log(modifiedWords);\n// // Обратите внимание, что есть три слова длиной менее 6, но так как они были изменены,\n// // возвращается одно слово ['spray']\n\n// ===========\n\n// // Добавление новых элементов\n// words = [\"spray\", \"limit\", \"exuberant\", \"destruction\", \"elite\", \"present\"];\n// const appendedWords = words.filter((word, index, arr) => {\n//   arr.push(\"new\")\n//   return word.length < 6;\n// });\n\n// console.log(appendedWords);\n// // Только три слова удовлетворяют условию, хотя `words` теперь имеет куда больше слов,\n// // длинной меньше 6 символов: ['spray', 'limit', 'elite']\n\n// ===========\n\n// // Удаление элементов\n// words = [\"spray\", \"limit\", \"exuberant\", \"destruction\", \"elite\", \"present\"];\n// const deleteWords = words.filter((word, index, arr) => {\n//   arr.pop();\n//   return word.length < 6;\n// });\n\n// console.log(deleteWords);\n// // Заметьте, что 'elite' не получено, так как удалено из `words` до того,\n// // как filter смог получить его: ['spray', 'limit']\n\n// ===============================================\n\n// const items = [\"item1\", \"item2\", \"item3\"];\n// const copy = [];\n\n// // до\n// for (let i = 0; i < items.length; i++) {\n//   copy.push(items[i]);\n//   console.log(items[i] + ' is result')\n// }\n\n// // после\n// const result3 = items.forEach(function (item) {\n//   copy.push(item);\n//   console.log(item + ' is result')\n// });\n\n// ===============================================\n\n// const numbers = [1,2,3,4,5]\n\n// let result = []\n// for (let i = 1; i < numbers.length + 1; i++) {\n//   result.push(i * 4)\n// }\n\n// console.log(result);\n\n// const result2 = numbers.map(function mul(element) {\n//   return element * 4;\n// })\n// console.log(result2);\n\n// const result = add(2, 3)\n\n// function add(a, b) {\n//   return a + b\n// }\n\n// console.log(result);\n\n// const added = function (x, y) {\n//   return x * y;\n// }\n\n// console.log(added(2, 1))\n\n// ===================\n\n// // setitem - добавить\n// // getItem - получить\n// // removeItem - удалить\n// // clear - очистить\n\n// // НЕ функция (и не метод объекта)\n\n// // объязательно привести в строку JSON.stringify!!!\n// localStorage.setItem('TEST_KEY', JSON.stringify([1,2,3,4]))\n// console.log(JSON.parse(localStorage.getItem('TEST_KEY')))\n\n// // объект\n// localStorage.setItem('TEST_KEY_1', JSON.stringify({name: 'hello'}))\n// console.log(JSON.parse(localStorage.getItem('TEST_KEY_1')));\n\n// localStorage.removeItem('TEST_KEY_1') // используется часто\n\n// // очистка (в случае логаута) - clear (редко)\n// // localStorage.clear()\n\n// ===================\n\n// const local = document.querySelector('.js-local')\n// const session = document.querySelector('.js-session')\n\n// local.addEventListener('click', () => {\n// localStorage.setItem('local', 'test local')\n// })\n\n// session.addEventListener('click', () => {\n// sessionStorage.setItem('session', 'test session')\n// })\n\n// const third = document.querySelector('.js-third')\n// third.addEventListener('click', () => {\n// localStorage.setItem('first', 'second')\n// })\n\n// const fourth = document.querySelector('.js-fourth')\n// fourth.addEventListener('click', () => {\n// sessionStorage.setItem('fourth', 'fifth')\n// })\n\n// ===================\n\n// АСИНХРОННОСТЬ\n\n// колстек проверяет тип функции\n// если синхронная - выполняется\n// если асинх - отправляется в WEB API\n// потом попадает в очередь и ждёт выполнения всех синх функций\n// весь асинх код будет всегда выполнен после синх\n\n// for (let i = 3; i > 0; i--) {\n//     const delay = i * 1000\n//     setTimeout(() => console.log(i), delay)\n// }\n\n// ===================\n\n// setTimeout(() => {\n//     console.log('Прошло >= 3 секунд после автосейва')\n// }, 3000)\n\n// ===================\n\n// console.log('start');\n\n// setTimeout(() => {\n//     console.log('SetTimeout');\n// }, 2000);\n\n// console.log('finish'); // 1. старт, 2. финиш, 3. SetTimeout\n\n// ===================\n\n// console.time('test async')\n\n// console.log('start')\n\n// setTimeout(() => {\n//     console.log('setTimeout')\n// }, 0)\n\n// for (let i = 0; i < 10000; i += 1) {\n//     console.log('value', i)\n// }\n\n// console.timeEnd(\n//     'test async'\n// ) /* выполняется синх, доходит до асинх, отправляет асинх в апи, после задержки отпрпавляет в очередь, выполняется после выполнения всего синх */\n\n// ===================\n\n// const date = new Date()\n// console.log('new Date()', date) // возвращает объект с датой на англ (удобно, чтобы получить какие-то значения)\n// const currentDate = Date.now()\n// console.log('Date.now()', currentDate) // возвращает кол-во милисекунду с 1 янв 1970 года (UTC)\n\n// ===================\n\n// Months\n// const date = new Date()\n\n// console.log(date.getMonth()) // 11 (декабрь) - возвращает месяц с нуля до 11 (вид массива), то есть декабрь - 11, апрель - 3\n// const months = [\n//     'Jan',\n//     'Feb',\n//     'Mar',\n//     'Apr',\n//     'May',\n//     'Jun',\n//     'Jul',\n//     'Aug',\n//     'Sep',\n//     'Oct',\n//     'Nov',\n//     'Dec',\n// ]\n\n// console.log(months[date.getMonth()]) // Dec\n\n// ===================\n\n// // Days\n\n// const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n// console.log(days[date.getDay()]) // Fri - счет ведётся с воскресенья (0 индекс)\n\n// ===================\n\n// // promises\n// const promise = new Promise((resolve, reject) => {\n//     reject('Oops')\n// })\n\n// promise.then(value => console.log(value)) // Uncaught (in promise) Oops\n\n// ===================\n\n// 1. Мікропроцеси мають більший пріоритет ніж макро\n// 2. Мікро: promise, observer\n// 3. Макро: setTimeout, setInterval, setImmediate, requestAnimationFrame\n\n// console.log('1')\n\n// setTimeout(() => console.log('2'), 0)\n\n// Promise.resolve('3').then(value => console.log(value))\n\n// console.log('4')\n\n// // 1 4 3 2\n// // синх, асинх: промис (микро), асинх:сеуттаймаут (макро)\n\n// ===================\n\n// console.log('1')\n\n// setTimeout(() => console.log('2'), 10)\n\n// Promise.resolve('3').then(value => console.log(value))\n// Promise.reject('4')\n//     .then(value => console.log(value))\n//     .catch(err => console.log(err))\n// Promise.resolve('5').then(value => console.log(value))\n\n// setTimeout(() => console.log('6'), 0)\n\n// console.log('7')\n\n// reject менеее приоритетный чем resolve\n// then требует внутри коллбек\n// нативный промисы используется в игровой разработке\n// приоритетность определяет очередь в event loop\n// 1 7 3 5 4 6 2\n\n// ===================\n\n// console.log('1')\n\n// setTimeout(() => {\n//     console.log('2')\n//     Promise.resolve('3').then(value => console.log(value))\n// }, 10)\n\n// console.log('4')\n\n// // промис попадает в очередь после выполнения resolve или reject\n// // синх, сеттаймаут идёт в апи, выполняется коллбек-функция сеттаймаута, возвращается 2, выполняется промис\n\n// ===================\n\n// // промис - обещание\n// // представитель класса\n// // 99% используется при запросе на бекенд\n// // 3 состояния промиса (2 типа событий)\n// // 1. Пендинг\n// // 2. Выполнение (3. resolve или fulfilled, reject)\n\n// // функция-экзекьютор (переданная функция для экземпляра промиса)\n// const promise = new Promise((resolve, reject) => {\n//     setTimeout(() => {\n//         const value = Math.random()\n\n//         if (value > 0.5) {\n//             resolve('Yeeeeees')\n//         } else {\n//             reject('Nooooo')\n//         }\n//     }, 1000)\n// })\n\n// // при отправке запроса на бекенд, промис в статусе пендинг, при получении - промис сам определяет статус\n\n// console.log(promise) // pending\n\n// // обрабатывается с помощью:\n// // then (принимает 2 коллбек-функции: resolve, reject (при этом в кетч он не попадёт)),\n// // catch,\n// // finally\n\n// // then всегда идёт первым, далее catch или finally\n// // каждый then возвращает промис\n\n// // структура: 1. список then(параметр удачного выполнения промиса), далее catch(параметр неудачного выполнения промиса) или finally(нет параметров)\n// promise\n//     .then(value => {\n//         return value + ' 😊'\n//     })\n//     .then(value => {\n//         console.log(value, qwerty)\n//     })\n//     .then(() => {\n//         console.log('last then')\n//     })\n//     .catch(err => {\n//         console.error(err)\n//     })\n//     .finally(() => {\n//         console.log('after')\n//     }) // не принимает параметры (выполняет общее действие при then и catch)\n\n// ===================\n\n// // создаем запрос на бекенд\n// // метод fetch\n// const promise = fetch('https://pokeapi.co/api/v2/pokemon/ditto')\n// console.log(promise) // {<pending>}\n\n// // возврат объекта, в котором есть асинх json (который обрабатывается в следующем then)\n// promise\n//     .then(response => response.json())\n//     .then(data => console.log(data))\n//     .catch(err => console.log(err))\n\n// ===================\n\nconst start = document.querySelector('.js-start')\nconst container = document.querySelector('.js-container')\n\nstart.addEventListener('click', onStart)\n\n// function onStart() {\n//     const result = []\n//     ;[...container.children].forEach(box => (box.textContent = ''))\n//     ;[...container.children].forEach((box, i) => {\n//         createPromise(i)\n//             .then(smile => {\n//                 box.textContent = smile\n//                 result.push('1')\n//             })\n//             .catch(smile => {\n//                 box.textContent = smile\n//             })\n//             .finally(() => {\n//                 setTimeout(() => {\n//                     if (i === container.children.length - 1) {\n//                         if (!result.length || result.length === 3) {\n//                             alert('Winner')\n//                         } else {\n//                             alert('Lost money')\n//                         }\n//                     }\n//                 }, 500)\n//             })\n//     })\n// }\n\n// function createPromise(delay) {\n//     return new Promise((resolve, reject) => {\n//         setTimeout(() => {\n//             const random = Math.random()\n\n//             if (random > 0.1) {\n//                 resolve('🍎')\n//             } else {\n//                 reject('🍉')\n//             }\n//         }, 1000 * delay)\n//     })\n// }\n\n// ===================\n//  методы промисов (11 модуль):\n\n// Promise.all() - если все промисы були успешны (если reject, падает в ошибку)\n// Promise.race() - возвращает первый самый быстрый промис\n// Promise.allSettled() - как Promise.all(), но обрабатывает все промисы и добавляет пометку статуса.\n\nfunction onStart() {\n    let counter = 0\n\n    ;[...container.children].forEach(box => (box.textContent = ''))\n\n    const promises = [...container.children].map((_, i) => createPromise(i))\n\n    Promise.allSettled(promises).then(items => {\n        items.forEach((item, i) => {\n            setTimeout(() => {\n                if (item.status === 'fulfilled') {\n                    counter += 1\n                }\n                container.children[i].textContent = item.value || item.reason\n\n                if (container.children.length - 1 === i) {\n                    setTimeout(() => {\n                        if (counter === container.children.length || !counter) {\n                            alert('Winner')\n                        } else {\n                            alert('Lost money')\n                        }\n                    }, 500)\n                }\n            }, i * 1000)\n        })\n    })\n}\n\nfunction createPromise() {\n    return new Promise((resolve, reject) => {\n        const random = Math.random()\n\n        if (random > 0.99) {\n            resolve('🍎')\n        } else {\n            reject('🍉')\n        }\n    })\n}\n"],"names":["Object","defineProperty","module","exports","value","default","arr","Array","isArray","$f215c72f040a88cf$var$_arrayLikeToArray","obj","parcelRequire","__esModule","len","length","i","arr2","iter","Symbol","iterator","from","TypeError","o","minLen","$7a2c4c4c44c69707$var$_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","test","$6195f07b5409ba15$exports","$6195f07b5409ba15$var$_arrayWithoutHoles","$6195f07b5409ba15$var$_iterableToArray","$6195f07b5409ba15$var$_unsupportedIterableToArray","$6195f07b5409ba15$var$_nonIterableSpread","$6195f07b5409ba15$var$_interopRequireDefault","$b9a42cf035ff9618$var$start","document","querySelector","$b9a42cf035ff9618$var$container","addEventListener","counter","$parcel$interopDefault","children","forEach","box","textContent","promises","map","_","Promise","resolve","reject","Math","random","allSettled","then","items","item","setTimeout","status","reason","alert"],"version":3,"file":"index.ab4ca0da.js.map"}
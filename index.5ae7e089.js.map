{"mappings":"AAwsBAA,YAAW,KACPC,QAAQC,IAAI,qCAA+D,GAC5E,KAwCH,MAAMC,EAAO,IAAIC,KAEjBH,QAAQC,IAAIC,EAAKE,YAgBjBJ,QAAQC,IAfO,CACX,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OAGeC,EAAKE,aAOxBJ,QAAQC,IADK,CAAC,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAC9CC,EAAKG","sources":["src/js/ownPractice/ownPractice.js"],"sourcesContent":["// const a = 2.55181;\n// console.log(a.toFixed(1)); // 2.2\n// console.log(Math.ceil(a)); // 3\n// console.log(Math.floor(a)); // 2\n// console.log(Math.round(a)); // 3\n\n// console.log(Math.max(21, 141, 51, 51, 51, 515, 15452)); // 15451\n// console.log(Math.min(21, 141, 51, 51, 51, 515, 15452)); // 21\n\n// // console.log(Math.pow(2, 4)); // 16\n// const math = Math.random() * (100 - 1) + 1;\n// const fixed = math.toFixed(0);\n// console.log(fixed);\n\n// const managerName = 'Andrey';\n\n// if (managerName === 'Serhii') {\n//   console.log('Yes');\n// } else if (managerName === 'Anton') {\n//   console.log('Manager Anton');\n// } else {\n//   console.log('Somebody else');\n// }\n\n// switch (managerName) {\n//   case 'Serhii':\n//     console.log('Yes');\n//     break;\n//   case 'Anton':\n//     console.log('Manager Anton');\n//     break;\n//   default:\n//     console.log('Somebody else');\n// }\n\n// ===========\n\n// const object = {\n//   name: 'Serhii',\n//   age: 30,\n//   height: 179,\n\n//   someData() {\n//     if (this.haveChildren) {\n//       console.log('yes, he have a children');\n//       return;\n//     } else {\n//       console.log('no, he haven`t any children');\n//       return;\n//     }\n//   },\n\n//   anotherData(companyName) {\n//     if (companyName) {\n//       console.log('ecosphere');\n//     } else {\n//       console.log('unemployed');\n//     }\n\n//     if (this.age > 30) {\n//       console.log('Yes, he is employee');\n//     } else if (this.age < 30) {\n//       console.log('early to work on this company');\n//     } else {\n//       console.log(`he is ${this.age}`);\n//     }\n//   },\n// };\n\n// object.haveChildren = true;\n\n// object.someData();\n// object.anotherData('ecosphere');\n\n// ===============================================\n\n// array methods\n\n// три основы, которые НЕОБХОДИМО знать:\n// A. что делает?\n// B. что принимает?\n// C. что возвращает?\n\n/* \n1. forEach() + callbacks - ничего не возвращает, только перебирает\n2. map()\n3. flatMap()\n4. filter()\n5. find() - ищет условие, которое соответствует true\n6. findIndex()\n7. every()\n8. some()\n9. sort()\n*/\n\n// ===========\n\n// 1\n// поэлементно перебирает массив, замена фор, ничего не возвраает, невозможно прервать итерацию\n\n// console.log('forEach:');\n\n// const numbers = [5, 10, 15, 20, 25];\n\n// console.log(numbers); // array\n\n// numbers.forEach((number) => {\n//   console.log(number); // elements of array\n// });\n\n// ===============================================\n\n// console.log('map:');\n\n// const numbers = [5, 10, 15, 20, 25];\n\n// // поэлементно перебирает каждый элемент, не изменяет оригинальный массив, возвращает новый массив такой же длинны\n// // неявный возврат возвращает undefined\n// const result = numbers.map((number) => {\n//   return number * 2;\n// });\n\n// console.log(result);\n\n// ===========\n\n// // получение массива имен игроков\n// const players = [\n//   { id: 'player-1', name: 'Mango', timePlayed: 310, points: 54, online: false },\n//   { id: 'player-2', name: 'Poly', timePlayed: 470, points: 92, online: true },\n//   { id: 'player-3', name: 'Kiwi', timePlayed: 230, points: 48, online: true },\n//   { id: 'player-4', name: 'Ajax', timePlayed: 150, points: 71, online: false },\n//   { id: 'player-5', name: 'Chelsy', timePlayed: 80, points: 48, online: true },\n// ];\n\n// const playersNames = players.map((player) => player.name);\n// console.log(playersNames); // array of players names\n\n// const playersIds = players.map((player) => player.id);\n// console.log(playersIds); // array of players ids\n\n// ===========\n\n// // для каждого игрока обновить свойства\n// const updatedPlayers = players.map((player) => {\n//   return {\n//     ...player,\n//     points: player.points * 1.1,\n//   };\n// });\n\n// console.log(updatedPlayers);\n\n// ===========\n\n// // достучаться до отдельного свойства отдельного объекта\n// const playerIdToUpdate = 'player-4';\n\n// const timePlayed = players.map((player) =>\n//   playerIdToUpdate === player.id\n//     ? { ...player, timePlayed: player.timePlayed + 100 }\n//     : player\n// );\n\n// const timePlayed = players.map((player) => {\n//   if (playerIdToUpdate === player.id) {\n//     return { ...player, timePlayed: player.timePlayed + 100 };\n//   }\n//   return player;\n// });\n\n// console.table(timePlayed);\n\n// ===============================================\n\n// console.log('filter:');\n\n/* \n- перебирает каждый элемент массива\n- фильтрует элементы по условию\n- возвращает новый массив (с элементами или пустой)\n- добавляет в массив элементы, которые удовлетворяет условию коллбек функции\ntrue - добавляется в новый массив\nfalse - не добавляется в новый массив\n*/\n\n// const numbers = [5, 10, 15, 20, 25];\n\n// const filtered = numbers.filter((number) => {\n//   console.log(number); // elements of array\n//   return number < 15 || number > 20;\n// });\n\n// console.log(filtered); // all elements who less than condition [5, 10,]\n\n// ===========\n\n// const players = [\n//   { id: 'player-1', name: 'Mango', timePlayed: 310, points: 54, online: false },\n//   { id: 'player-2', name: 'Poly', timePlayed: 470, points: 92, online: true },\n//   { id: 'player-3', name: 'Kiwi', timePlayed: 230, points: 48, online: true },\n//   { id: 'player-4', name: 'Ajax', timePlayed: 150, points: 71, online: false },\n//   { id: 'player-5', name: 'Chelsy', timePlayed: 80, points: 48, online: true },\n// ];\n\n// const filteredOnline = players.filter((player) => player.online);\n// console.table(filteredOnline);\n\n// const filteredOffline = players.filter((player) => !player.online);\n// console.table(filteredOffline);\n\n// ===============================================\n// little shallow\n\n// const myVar = 'string';\n\n// function someFunc() {\n//   const myVar = 'another string';\n//   console.log(myVar);\n//   return myVar;\n// }\n\n// console.log(myVar === someFunc()); // false\n\n// ===============================================\n\n// const counter = {\n//   value: 0,\n//   increment(value) {\n//     console.log('increment -> this', this);\n//     this.value += value;\n//   },\n//   decrement(value) {\n//     console.log('decrement -> this', this);\n//     this.value -= value;\n//   },\n// };\n\n// const updateCounter = function (value, operation) {\n//   operation(value);\n// };\n\n// updateCounter(10, counter.increment); // undefined (нету контекста)\n// updateCounter(5, counter.decrement); // undefined (нету контекста)\n\n// // ПРИ ПЕРЕДАЧЕ МЕТОДА ОБЪЕКТА, КАК КОЛЛБЕКА - КОНТЕКСТ НЕ СОХРАНЯЕТСЯ\n\n// ===============================================\n\n// const func = function () {\n//   return 5;\n// };\n\n// console.log(func); // передана ссылка на функцию, а не вызов\n\n// ===============================================\n\n// // call/apply - принудительный вызов функции в контексте (ТОЛЬКО НА ОДИН ВЫЗОВ)\n// // функция - это объект\n\n// // fn.call(ссылка на объект (контекст), остальные необязательные аргументы)\n\n// const func = function () {\n//   console.log('this', this);\n// };\n\n// const objA = {\n//   a: 5,\n//   b: 10,\n// };\n\n// func.call(objA, 1, 2, 3, 4, 5); // контекст, передача необязательных аргументов\n// func.apply(objA, [1, 2, 3, 4, 5]); // контекст, передача необязательных аргументов в массиве\n\n// // не хранить одинаковые методы на объектах, а вынести одну независимую и потом вызвать в каком-то контекте\n\n// ===============================================\n\n// // bind() - привязка контекста НАВСЕГДА\n// // делает копию метода и привязывает контекст НАВСЕГДА\n// // оригинальная функция не изменяется\n\n// const counter = {\n//   value: 0,\n//   increment(value) {\n//     console.log('increment -> this', this);\n//     this.value += value;\n//   },\n//   decrement(value) {\n//     console.log('decrement -> this', this);\n//     this.value -= value;\n//   },\n// };\n\n// const updateCounter = function (value, operation) {\n//   operation(value);\n// };\n\n// updateCounter(10, counter.increment.bind(counter));\n// updateCounter(5, counter.decrement.bind(counter));\n\n// ===============================================\n\n// const objectC = {\n//   first: 1,\n// };\n// console.log(objectC);\n\n// const objectB = Object.create(objectC);\n// objectB.second = 2;\n// console.log(objectB);\n\n// const objectA = Object.create(objectB);\n// objectA.third = 3;\n// console.log(objectA);\n\n// ===============================================\n\n// const User = function ({ email, password } = {}) {\n//   this.email = email;\n//   this.password = password;\n// };\n\n// // console.log(User.prototype); // автоматически создаётся объект\n\n// User.prototype.changeEmail = function (newMail) {\n//   this.email = newMail;\n// };\n\n// const mango = new User({ email: 'mango@mail.com', password: 11111 });\n\n// mango.changeEmail('my-new-mail@mail.com');\n\n// User.logInfo = function (obj) {\n//   console.log(obj);\n// };\n\n// User.logInfo(mango);\n\n// ===============================================\n\n// const object = {\n//   name: 'Serhii',\n//   age: 35,\n// };\n\n// console.log(object);\n\n// object.profession = 'Developer';\n\n// console.log(object.hasOwnProperty('profession'));\n\n// const newInfo = Object.create(object); // прототип объекта object\n// newInfo.profession = 'Manager'\n\n// console.log(newInfo.hasOwnProperty('profession'));\n\n// ===============================================\n\n// const numbers = [1, 2, 3, 4, 5];\n\n// const result = numbers.every((number) => number < 0);\n// console.log(result);\n\n// const result2 = numbers.some((number) => number > 5);\n// console.log(result2);\n\n// const arrayOfObjects = [\n//   { name: 'first', first: 1 },\n//   { name: 'second', second: 2 },\n//   { name: 'third', third: 3 },\n// ];\n\n// const footballers = ['Harry Kane', 'Hugo Lloris', 'Christian Eriksen'];\n\n// const changeToUpper = footballers.map((footballer) => footballer.toUpperCase());\n// console.log(changeToUpper);\n\n// const changeToLower = footballers.map((footballer) => footballer.toLowerCase());\n// console.log(changeToLower);\n\n// const footballers = [\n//   { name: 'Harry Kane', clubs: 'Bayern Munich' },\n//   { name: 'Hugo Lloris', clubs: 'Tottenham Hotspur' },\n//   {\n//     name: 'Christian Eriksen',\n//     clubs: 'Manchester United',\n//   },\n// ];\n\n// const findClub = footballers.find(\n//   (footballer) => footballer.clubs === 'Tottenham Hotspur'\n// );\n// console.log(findClub);\n\n// const findClubByIndex = footballers.findIndex(\n//   (footballer) => footballer.clubs === 'Tottenham Hotspur'\n// );\n// console.log(findClubByIndex);\n\n// const footballers = [\n//   { name: 'Harry Kane', clubs: ['Tottenham Hotspur', 'Bayern Munich'] },\n//   { name: 'Hugo Lloris', clubs: ['Nice', 'Tottenham Hotspur'] },\n//   {\n//     name: 'Christian Eriksen',\n//     clubs: ['Tottenham Hotspur', 'Manchester United'],\n//   },\n// ];\n\n// const clubs = footballers.flatMap((footballer) => footballer.clubs);\n// console.log(clubs);\n\n// const oneClub = clubs.filter((club, idx, arr) => arr.indexOf(club) === idx);\n// console.log(oneClub);\n\n// ===============================================\n\n// //  ЗАДАЧА С КАРТАМИ\n// let count = 0;\n\n// function cc(card) {\n//   switch (card) {\n//     case 2:\n//     case 3:\n//     case 4:\n//     case 5:\n//     case 6:\n//       count += 1;\n//       break;\n\n//     case 10:\n//     case \"J\":\n//     case \"Q\":\n//     case \"K\":\n//     case \"A\":\n//       count -= 1;\n//       break;\n//   }\n\n//   if (count > 0) {\n//     return console.log(count + \" Bet\");\n//   } else {\n//     return console.log(count + \" Hold\");\n//   }\n// }\n\n// cc(2); cc(3); cc(7); cc('K'); cc('A');\n\n// ===============================================\n\n// РЕКУРСИЯ\n// Два основных правила:\n// // 1. базовое условие\n// // 2. движение по рекурсии (сценарий)\n\n// let count = 0\n\n// function recurse() {\n//   if(count === 5) {\n//     return 'Done'\n//   }\n\n//   count++;\n//   return recurse();\n// }\n\n// console.log(recurse())\n// console.log(count);\n\n// ===========\n\n// function pow(x, y) {\n//   if (y === 0) {\n//     return 1;\n//   }\n//   return x * pow(x, y - 1)\n// }\n\n// const result = pow(5, 3)\n// console.log(result);\n\n// ===========\n\n// const contacts = [\n//   {\n//     firstName: \"Akira\",\n//     lastName: \"Laine\",\n//     number: \"0543236543\",\n//     likes: [\"Pizza\", \"Coding\", \"Brownie Points\"],\n//   },\n//   {\n//     firstName: \"Harry\",\n//     lastName: \"Potter\",\n//     number: \"0994372684\",\n//     likes: [\"Hogwarts\", \"Magic\", \"Hagrid\"],\n//   },\n//   {\n//     firstName: \"Sherlock\",\n//     lastName: \"Holmes\",\n//     number: \"0487345643\",\n//     likes: [\"Intriguing Cases\", \"Violin\"],\n//   },\n//   {\n//     firstName: \"Kristian\",\n//     lastName: \"Vos\",\n//     number: \"unknown\",\n//     likes: [\"JavaScript\", \"Gaming\", \"Foxes\"],\n//   },\n// ];\n\n// function lookUpProfile(name, prop) {\n// for (let x = 0; x < contacts.length; x++) {\n//   if (contacts[x].firstName === name) {\n//     if (contacts[x].hasOwnProperty(prop)) {\n//       return contacts[x][prop]\n//     } else {\n//       return 'No such property'\n//     }\n//   }\n// }\n// return 'No such contact'\n// }\n\n// lookUpProfile(\"Akira\", \"likes\");\n\n// ===========\n\n// function randomWholeNum() {\n//   return (Math.floor(Math.random() * 9));\n// }\n\n// console.log(randomWholeNum());\n\n// ===========\n\n// function convertToInteger(str) {\n//   return parseInt(str)\n//   }\n\n// console.log(convertToInteger(\"56\"));\n\n// ===========\n\n// function checkSign(num) {\n//   return num > 0 ? 'positive'\n//   : num < 0 ? 'negative'\n//   : 'zero'\n// }\n\n// (checkSign(10));\n\n// ===============================================\n\n// const words = ['spray', 'elite', 'exuberant', 'destruction', 'present'];\n// const result = words.filter((word) => word.length > 6);\n// console.log(result); // [\"exuberant\", \"destruction\", \"present\"]\n\n// ===========\n\n// const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n// const result2 = arr.filter((element) => element < 5)\n// console.log(result2);\n\n// ===========\n\n// // Изменение всех элементов\n// let words = [\"spray\", \"limit\", \"exuberant\", \"destruction\", \"elite\", \"present\"];\n\n// const modifiedWords = words.filter((word, index, arr) => {\n//   arr[index + 1] += \" extra\";\n//   return word.length < 6;\n// });\n\n// console.log(modifiedWords);\n// // Обратите внимание, что есть три слова длиной менее 6, но так как они были изменены,\n// // возвращается одно слово ['spray']\n\n// ===========\n\n// // Добавление новых элементов\n// words = [\"spray\", \"limit\", \"exuberant\", \"destruction\", \"elite\", \"present\"];\n// const appendedWords = words.filter((word, index, arr) => {\n//   arr.push(\"new\")\n//   return word.length < 6;\n// });\n\n// console.log(appendedWords);\n// // Только три слова удовлетворяют условию, хотя `words` теперь имеет куда больше слов,\n// // длинной меньше 6 символов: ['spray', 'limit', 'elite']\n\n// ===========\n\n// // Удаление элементов\n// words = [\"spray\", \"limit\", \"exuberant\", \"destruction\", \"elite\", \"present\"];\n// const deleteWords = words.filter((word, index, arr) => {\n//   arr.pop();\n//   return word.length < 6;\n// });\n\n// console.log(deleteWords);\n// // Заметьте, что 'elite' не получено, так как удалено из `words` до того,\n// // как filter смог получить его: ['spray', 'limit']\n\n// ===============================================\n\n// const items = [\"item1\", \"item2\", \"item3\"];\n// const copy = [];\n\n// // до\n// for (let i = 0; i < items.length; i++) {\n//   copy.push(items[i]);\n//   console.log(items[i] + ' is result')\n// }\n\n// // после\n// const result3 = items.forEach(function (item) {\n//   copy.push(item);\n//   console.log(item + ' is result')\n// });\n\n// ===============================================\n\n// const numbers = [1,2,3,4,5]\n\n// let result = []\n// for (let i = 1; i < numbers.length + 1; i++) {\n//   result.push(i * 4)\n// }\n\n// console.log(result);\n\n// const result2 = numbers.map(function mul(element) {\n//   return element * 4;\n// })\n// console.log(result2);\n\n// const result = add(2, 3)\n\n// function add(a, b) {\n//   return a + b\n// }\n\n// console.log(result);\n\n// const added = function (x, y) {\n//   return x * y;\n// }\n\n// console.log(added(2, 1))\n\n// ===================\n\n// // setitem - добавить\n// // getItem - получить\n// // removeItem - удалить\n// // clear - очистить\n\n// // НЕ функция (и не метод объекта)\n\n// // объязательно привести в строку JSON.stringify!!!\n// localStorage.setItem('TEST_KEY', JSON.stringify([1,2,3,4]))\n// console.log(JSON.parse(localStorage.getItem('TEST_KEY')))\n\n// // объект\n// localStorage.setItem('TEST_KEY_1', JSON.stringify({name: 'hello'}))\n// console.log(JSON.parse(localStorage.getItem('TEST_KEY_1')));\n\n// localStorage.removeItem('TEST_KEY_1') // используется часто\n\n// // очистка (в случае логаута) - clear (редко)\n// // localStorage.clear()\n\n// ===================\n\n// const local = document.querySelector('.js-local')\n// const session = document.querySelector('.js-session')\n\n// local.addEventListener('click', () => {\n// localStorage.setItem('local', 'test local')\n// })\n\n// session.addEventListener('click', () => {\n// sessionStorage.setItem('session', 'test session')\n// })\n\n// const third = document.querySelector('.js-third')\n// third.addEventListener('click', () => {\n// localStorage.setItem('first', 'second')\n// })\n\n// const fourth = document.querySelector('.js-fourth')\n// fourth.addEventListener('click', () => {\n// sessionStorage.setItem('fourth', 'fifth')\n// })\n\n// ===================\n\n// АСИНХРОННОСТЬ\n\n// колстек проверяет тип функции\n// если синхронная - выполняется\n// если асинх - отправляется в WEB API\n// потом попадает в очередь и ждёт выполнения всех синх функций\n// весь асинх код будет всегда выполнен после синх\n\n// for (let i = 3; i > 0; i--) {\n//     const delay = i * 1000\n//     setTimeout(() => console.log(i), delay)\n// }\n\n// ===================\n\nsetTimeout(() => {\n    console.log('Прошло >= 3 секунд после автосейва')\n}, 3000)\n\n// ===================\n\n// console.log('start');\n\n// setTimeout(() => {\n//     console.log('SetTimeout');\n// }, 2000);\n\n// console.log('finish'); // 1. старт, 2. финиш, 3. SetTimeout\n\n// ===================\n\n// console.time('test async')\n\n// console.log('start')\n\n// setTimeout(() => {\n//     console.log('setTimeout')\n// }, 0)\n\n// for (let i = 0; i < 10000; i += 1) {\n//     console.log('value', i)\n// }\n\n// console.timeEnd(\n//     'test async'\n// ) /* выполняется синх, доходит до асинх, отправляет асинх в апи, после задержки отпрпавляет в очередь, выполняется после выполнения всего синх */\n\n// ===================\n\n// const date = new Date()\n// console.log('new Date()', date) // возвращает объект с датой на англ (удобно, чтобы получить какие-то значения)\n// const currentDate = Date.now()\n// console.log('Date.now()', currentDate) // возвращает кол-во милисекунду с 1 янв 1970 года (UTC)\n\n// ===================\n\n// Months\nconst date = new Date()\n\nconsole.log(date.getMonth()) // 11 (декабрь) - возвращает месяц с нуля до 11 (вид массива), то есть декабрь - 11, апрель - 3\nconst months = [\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec',\n]\n\nconsole.log(months[date.getMonth()]) // Dec\n\n// ===================\n\n// Days\n\nconst days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\nconsole.log(days[date.getDay()]) // Fri - счет ведётся с воскресенья (0 индекс)\n"],"names":["setTimeout","console","log","$b45a35447b03d6b8$var$date","Date","getMonth","getDay"],"version":3,"file":"index.5ae7e089.js.map"}